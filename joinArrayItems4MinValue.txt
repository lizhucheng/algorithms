题目：输入一个正整数数组，把数组中所有的数拼接成一个整数，输出最小的整数。
例如输入数组[3, 32, 321]，则打印出这三个数字能排成的最小数字为321323。

代码  function fn(arr) {
  return arr.map(item => item.toString()).sort((a, b) => {
    const ab = a + b;
    const ba = b + a;
    return ab > ba ? 1 : -1;
  }).join('');
}

分析：（标记说明，mn表示整数m、n作为字符串拼接后的字符串，字符串按字典序定义<关系）
不管怎么排列，最终输出的数字串的位数是相同的，要使这个数的值最小，显然高位越小的串值越小；
第一想法，越小的数字开头的数应该放在最前面; 这样逐个比较数值对应的字符串，按字符字典序比较，小的字符串放前面肯定没毛病；
但存在一个问题，当一个数字串是另外一个的数字串前缀的时候很难判断哪个放前面合适，因为还可能存在别的小的串拼起来比长串大也可能小；
瞬间懵逼。
退而分析必要条件，看看满足最小要求的输出值应该满足啥条件。
如果一个输出串的值最小，那就意味着任意两个数调换位置不能更小，也就是说对于x1,x2,x3,...xn, 
任意 1<=i,j(j=i+1)<=n, 字符串连接 xixj <= xjxi；也就是说必要条件是满足 mn < nm 关系的两个数，m必然在前面。
进而探索充分性，是否满足 mn < nm 的元素m、n， 使得m排在n前面的数组排序后输出的字符串就是最小呢？

证明：
1. 定义正整数集合上的关系 <<=： 正整数m、n, 当 mn <= nm 时，称为 m <<= n;
由于任意两个字符串可以按字典序比较顺序，所以 mn和nm是可以比的，即 mn <= nm || nm <= mn; 即 m <<= n 或 n <<= m;(完全性)
考察 mn = nm的情况：
mn = nm,  使用 m.len 表示整数m的字符串长度, 不妨假设 m.len >= n.len;
等式说明 n为m的前缀也为m的后缀，可以把m 表示为两部分， 设 m=nq, 代入得 nqn = nnq, 去掉相同的前缀n，得 qn = nq;
同理如果 q.len >= n.len的长度，可以不断执行这个拆分过程，不妨把 m 表示成 {nk}q，即 m = {nk}q (nk表示k个n， q.len < n.len);
带人式子得 {nk}qn = n{nk}q ,去掉相同的前缀 {nk}得  qn=nq; 由于q.len < n.len; 此时n和q相当于之前的m、n;
同理不断迭代，q的字符串长度一直递减，若干次循环后，q会变成 空字符串, 依旧是最终存在等式 n={qk},也就是n为q的多次循环得到的串；
进而m也是 q的多次循环的串; 所有由一个无循环的串p循环生成的串的集合可以表示为 {p}, 这个集合包含 p, pp, ppp, ...;
显然任意{p}的元素 r、t, r <<= t 且 t <<= r; 
且可以证明{p} = {q} <=> p = q; 
(必要性显然，p=q时，{p}={q}; 整充分性：{p}={q} => q 属于 {p} <=> q = {pk}, 根据定义q不是循环串，所以k=1，即q=p);
可以证明任意{p}中的元素r, 以及任意正整数 m，如果 m <<= p，则 m <<= r; 如果 p <<= m, 则 r <<= m; 
即{p}中的元素在 <<= 关系上是一致的；
不妨假设 r = {pk}; p <<= m <=> pm <= mp, rm = {pk}m = {p(k-1)}pm <= {p(k-1)}mp <= {p(k-2)}m{p2} <= m{pk} = mr, 即r <<= m;
同理 m <<= p <=> mp <= pm, mr = m{pk} = mp{p(k-1)} < pm{p(k-1)} < {pk}m = rm, 即 m <<= r;
可以基于 <<= 关系定义 等价关系 === , 当 m <<= n 且 n <<= m 时，称m === n;
可以证明对应不循环的串p, {p} 包含了所有和p相等的元素，即任意 r === p, r必属于{p};
证：{p}中的元素t显然满足 t===p; 
  对应任意 r===p, 根据之前 mn <<= nm 且 nm <<=mn的结论，存在 {q}, r,p 都属于{q}; p 属于{q} => p={qk},由于p不循环 => k=1,即p=q.
综上，关系 === 对整数集合进行了等价划分，每个等价类中的元素都可表示为{p}的形式 (p为不循环的串)；
在这个等价划分集合中可以定义 划分之间的关系 << , 对于等价类 {p} {q}, 当 p <<= q 时 称 {p} <<= {q};
可以证明在等价划分集合中的 <<= 关系是全序关系。
（1）反对称性(如果{p} <<= {q} 且 {q} <<= {p}, 则 {p} = {q})
  基于{p}和{q}的定义, 显然满足；
（2）传递性( 如果 {a} <<= {b} 且 {b} <<= {c}, 则 {a} <<= {c});
  设a, b, c的字符串长度分别为 n, m, k；
  证明： {a} <<= {b} <=> a <<= b <=> ab <= ba <=> a * 10^m + b <= b * 10^n + a; ----#1
     {b} <<= {c} <=> b <<= c <=> bc <= cb <=> b * 10^k + c <= c * 10^m + b; -----#2
     ca = c * 10^n + a
      >= c/b * (a * 10^m + b - a) + a   // 由#1可得
      = a/b(c*10^m + b - b) + c - ac/b + a
      >= a/b(b * 10^k + c - b) + c - ac/b + a // 由#2可得
      = a*10^k + ac/b - a + c - ac/b + a
      = a*10^k + c = ac;

      => a <<= c;
（3）完全性（任意 {p} {q}, 必存在{p} <<= {q} 或 {q} <<= {p})
  这个由 p <<= q 或 q <<= p的完全性自然得出；

综上，整数上的关系 <<= 为 全序关系。（也可以定义关系 << : 任意划分 {p}、 {q}, 当 p << q 即 pq < qp时 称 {p} << {q} ）

下面证明 按全序关系 <<= 排序的数组 x1,x2,x3,...xn 输出的字符串值最小。
可以证明任意交换两个元素的位置，可以按<<= 关系把元素调整为有序，可以按冒泡的方式调整元素，
由于每次调整值都是不会变大，最终值肯定<=未排序时的输出。
即如果x1 <<= x2 <<= x3 <<= x4，则x1x2x3x4是最小的数。
假如任意交换其中的2个数x2和x4，x1x2x3x4x5 <<= x1x2x4x3x5 <<= x1x4x2x3x5 <<= x1x4x3x2x5.
综上基于全序关系 <<= 排序后的数组产生的拼接值最小。
